<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      var arr1 = [1, 2, 3];
      var arr2 = [3, 4, 5];
      if (arr1.some((x) => arr2.includes(x))) {
        console.log("OK TRUE");
      }
      // "use strict";
      var arr = [1, 2, 3, 4];
      arr.forEach((e) => console.log(e));
      var str = "aloalo";
      var newArr = Array.from(str);
      console.log(newArr);
      console.log(arr.includes(2));
      function redu(a, b) {
        return a + b;
      }
      var res = arr.reduce(redu);
      console.log(res);
      const iterator = arr.values();

      for (const i of iterator) {
        console.log(i);
      }
      var today = Date.parse("March 21, 2012");
      var today_2 = new Date(today);
      console.log(today_2);
      var day = new Date();
      console.log(day.getHours());
      console.log(Math.PI);
      console.log(Math.LOG2E);
      console.log(Math.round(4.33));
      console.log(Math.ceil(4.334));
      console.log(Math.floor(4.333));
      console.log(Math.trunc(4.5555));
      console.log(Boolean(10 > 2));
      for (let index in arr) {
        console.log(arr[index]);
      }
      arr.forEach((e) => {
        console.log(e);
      });

      for (let x of arr) {
        console.log(x);
      }
      var numb = 1001011;
      parseInt(numb, 2);
      console.log(numb);
      var dec = numb.toString(10);
      console.log(dec);

      // hoisting
      catName("Chloe");

      function catName(name) {
        console.log("My cat's name is " + name);
        var y = 5;
        console.log(y);
        // let y; -> reference error. cannot access to y variable

        // callback: Hàm này là đối số của hàm kia
        // method 1
        function doHomework(subject, callback) {
          console.log(`Bắt đầu làm bài tập ${subject}`);
          callback();
        }
        doHomework("Toán", () => {
          console.log("Đã làm xong bài tập!");
        });

        // method2
        function doHomework2(subject, callback) {
          setTimeout(() => {
            console.log(`Bat dau lam bai tap ${subject}`);
            callback();
          }, 3000);
        }
        var alertFinish = () => {
          console.log("Da lam xong bai tap!");
        };
        doHomework2("Toan", alertFinish);

        // asynchronous js

        const second = () => {
          console.log("Hello there!");
        };
        const first = () => {
          console.log("Hi there!");
          second();
          console.log("The End");
        };
        first();
      }
      // CALL STACk(LIFO): main()->first()->console.log('Hi there!') -> pop -> second()->console.log('Hello there!')->popx20->console.log('The end!')->pop->pop->pop -> end

      // What is blocking in JS?

      // Chan call stack hay con goi la chan main thread
      // solution: su dung callbacks de unblock callstack
      // execution context: la moi truong noi js code duoc thuc thi, bat ky khi nao js code thuc thi no chay trong mot execution context.
      // call stack: la noi luu tru tat ca execution context duoc tao ra trong qua trinh thuc thi code
      // event loop, webAPIs, message queue la mot phan cua moi truong thuc thi JS cua browser hay moi truong thuc thi NodeJS JS

      const networkRequest = () => {
        setTimeout(() => {
          console.log("Async Code");
        }, 2000);
      };
      console.log("Hello World");
      networkRequest();
      console.log("The End");
      // Đầu tiên thì console.log('Hello World') sẽ dược đưa vào Call Stack->sau khi thực thi thì nó sẽ được pop ra ngoài
      // Tiếp theo hàm networkRequest() được push vào Callstack -> hàm setTimeout được push vào calltack và thực thi -> sau đó thông qua WebAPIs trả về dữ liệu và được
      // thêm vào Message queue -> sau đó thông qua Event loop trả ngược về callstack, sau khi thực hiện xong hàm setTimeout đc pop ra ngoài
      // Hàm networkRequest() được pop ra sau đó -> tiếp theo console.log('The End'); được push vào call stack thực thi và bị pop ra ngoài -> hàm main được pop ra ngoài -> callstack rỗng -> kết thúc chương trình
      // Even loop: Sau khi call stack rỗng, thằng event loop sẽ nhìn qua thằng message queue xem còn có callback nào cần được thực thi hay không? Và nhiệm vụ của nó là pop callback vào callstack
      // Message queue: Nhận callbacks chờ được thực thi từ WebAPIs

      const bar = () => {
        console.log("bar");
      };

      const baz = () => {
        console.log("baz");
      };
      const foo = () => {
        console.log("foo");
        setTimeout(bar, 0);
        new Promise((resolve, reject) => {
          resolve("Primise solved");
        })
          .then((res) => console.log(res))
          .catch((err) => console.log(err));
        baz();
      };

      foo();
      // Mức độ ưu tiên của job queue cao hơn message queue

      // promise in JS: pending, fulfilled, rejected
      const promise = doSomething();
      const promise2 = doSomething()
        .then(successCallback)
        .cath(failureCallback);
      // .catch(failureCallback) = .then(null, failureCallback)

      // Kim tu thap
      doSomething(function (result) {
        doSomethingElse(
          result,
          function (newResult) {
            doThirdThing(
              newResult,
              function (finalResult) {
                console.log("Got the final result: " + finalResult);
              },
              failureCallback
            );
          },
          failureCallback
        );
      }, failureCallback);

      // Su dung promise
      doSomething()
        .then(function (result) {
          return doSomethingElse(result);
        })
        .then(function (newResult) {
          return doThirdThing(newResult);
        })
        .then(function (finalResult) {
          console.log("Got the final result: " + finalResult);
        })
        .catch(failureCallback);
    </script>
  </body>
</html>
